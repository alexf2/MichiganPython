'''
Утиная типизация - это динамическая типизация, основанная на частичной поддержке одного или нескольких протоколов.
В этом подходе важен не тип объекта, а какие методы он и свойства он поддерживает. Не важен способ их получения (наследование, композиция).
Так же, допускается частичная поддержка. Имеется аналог интерфейса в статической типизации - Protocol.

Protocol, в отличие от интерефейса, описывает не тип, а каким должно быть поведение. Причём, добавляться методы могут динамически, 
во время выполнения.

Кратко говоря: Interface в статической типизации - это базовый тип, а Protocol - это динамическое поведение.

Или: игнорирование	 фактического	 типа	 объекта	 и  акцент	 на	 то,	чтобы	 объект	 реализовывал	 методы	 с  именами,	 
сигнатурами	 и  семантикой,	требуемыми	для	конкретного	применения.

Утиная типизация особенно эффективна для плагинов.

Отсюда и два разных подхода к написанию кода:
  1) статическая типизация - мы проверяем isinstance объекта;
  2) динамическая типизация - мы проверяем поддержку нужного метода. Используется принцип БЫСТРОГО ОТКАЗА вместо проверки типа.
  
В Питоне имеются базовые ABC для коллекций: Container, Iterable, Sized, Collection, Sequence.
Они определяют протоколы,но их наследовать не обязательно. И можно поддерживать протокол частично.

"Правильно	 написанный	 подкласс	 Sequence должен	 реализовывать	 методы	 __getitem__ и  __len__ (унаследованный	 от	 Sized) .	
Все	 остальные	 методы	 Sequence	 конкретные,	 поэтому	 подклассы	 могут	 унасле- довать	их	реализации	или	предоставить	собственные"
'''


from collections import abc
from collections.abc import Sequence
from typing import Protocol, TypeVar, runtime_checkable


def __init__(self, iterable):
    self._balls = list(iterable)
# тут мы не проверяем isinstance(iterable, list), а строим сразу же list. Это гибкий подход: если объект итерируемый, то построится list,
# а иначе будет быстрый отказ.


try:
    # тут если нет split, то попробуем создать картеж (итерируемость)
    field_names = field_names.replace(',', ' ').split()
except AttributeError:
    pass
# а тут будет ранний отказ, если это не str и не Iterable
field_names = tuple(field_names)
if not all(s.isidentifier() for s in field_names):
    raise ValueError('field_names must all be valid identifiers')


# Гусиная	типизация –	это	подход	к проверке	типов	во	время	выполнения,	ос- нованный	на	применении	ABC.
# Она проверяется через isinstance, но только на основе ABC (второй аргумет всегда какой-нибудь класс из ABC).


class Struggle:
    def __len__(self):
        return 123


isinstance(Struggle(), abc.Sized)  # вернёт True, так как есть __len__.

'''
Таким	образом,	гусиная типизация	подразумевает:
  - порождение	подклассов	ABC,	чтобы	было	ясно,	что	мы	реализуем	ранее	определенный	интерфейс;
  - проверку	 во	 время	 выполнения	 с  указанием	 ABC	 вместо	 конкретных	классов	в качестве	второго	аргумента	функций	isinstance	и issubclass.
'''

# Виртуальные субклассы


class MyList(list):
    pass  # обычный list, но добавим метод


MySequence = Sequence.register(MyList)  # регистрация как виртуальный подкласс

obj = MyList([1, 2, 3])
print(issubclass(MyList, Sequence))  # True
print(isinstance(obj, Sequence))     # True

# многие встроенные типы зрегистрированы как виртуальные субклассы:
Sequence.register(tuple)
Sequence.register(str)
Sequence.register(range)
Sequence.register(memoryview)

# Пример протокола

T = TypeVar('T')  # Это аналог дженерика


class Repeatable(Protocol):
    def __mul__(self: T, repeat_count: int) -> T:
        ...


# А тут мы требуем, чтобы реализовывался Repeatable
RT = TypeVar('RT', bound=Repeatable)


def double(x: RT) -> RT:
    return x * 2


ll = [1, 2]

print(double(ll))

'''
при	 определении	 под- класса	 typing.Protocol	 мы	 можем	 использовать	 декоратор	 @runtime_checkable,	 
что - бы	 протокол	 поддерживал	 проверки	 с  помощью	 функций	 isinstance/issubclass во	 время	 выполнения.	 
Это	 работает,	 потому	 что	 typing.Protocol  –	 абстрактный	базовый	 класс,	 а  значит,	 поддерживает	 метод	 __subclasshook__.
'''


@runtime_checkable
class Closable(Protocol):  # Runtime-протокол
    def close(self) -> None:
        ...


# Работает!
print(isinstance(open('file.txt'), Closable))  # True (duck typing на runtime)

# Протоколы выгодно делать узкими, с одним-двумя методами, чтобы не было тесной связи, а потом расширять наследованием


@runtime_checkable
class LoadableRandomPicker(RandomPicker, Protocol):
    def load(self, Iterable) -> None:
        ...


'''
- Если	нужно,	чтобы	производный	протокол	допускал	проверку	во	время	выполнения,	то	необходимо	повторно	применить	к нему	декоратор –	это	
поведение не наследуется.

-	Для	 любого	 протокола	 необходимо	 явно	 указать	 typing.Protocol	 в  качестве	одного	 из	 базовых	 классов,	 в  дополнение	 к  
расширяемому	 протоколу.	Обычное	наследование	в Python	работает	не так.

-	Возвращаемся	 к  «регулярному»	 ООП:	 нужно	 объявлять	 только	 новый	 ме- тод	 производного	 протокола.	 Объявление	 метода	 
pick	 унаследовано	 от	RandomPicker.
'''

# Способы определения и использования интерфейсов в Питоне:
# 1. УТиная типизация
# 2. Гусиная типизация - это наследование от ABC и применение isinstance по отношению к ABC
# 3. Статическая типизация - это как в Java, в Питоне используются typing и Mypy
# 4. Статическая утиная типизация - это использование typing.Protocol для динамичекой проверки isinstance
